%% Fibonacci numbers.
% The 
% <http://en.wikipedia.org/wiki/Fibonacci_number |Fibonacci numbers|>
% are an easily accessible area in
% number theory. As well, they appear in many places 
% in mathematics and in 
% <http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibnat.html |nature|>
% , 
% <http://www.branta.connectfree.co.uk/fibonacci.htm |look here too|>
% . For those interested in reading more about Fibonacci
% numbers, you might look at the
% <http://www.engineering.sdstate.edu/~fib/ |Fibonacci Quarterly|>
% .
%
% I've found many of the Project Euler problems to be interesting and mentally 
% stimulating. Here are a few on Fibonacci numbers: {
% <http://projecteuler.net/index.php?section=problems&id=2 |#2|>
% ,
% <http://projecteuler.net/index.php?section=problems&id=25 |#25|>
% ,
% <http://projecteuler.net/index.php?section=problems&id=104 |#104|>
% ,
% <http://projecteuler.net/index.php?section=problems&id=137 |#137|>
% }.
%
% Less well known than the Fibonacci numbers are the closely related
% <http://en.wikipedia.org/wiki/Lucas_number |Lucas numbers.|>
%
% <http://www.mathpropress.com/stan/bibliography/algorithmicFib.pdf |Here is a good reference on the manipulation and derivation of identities relating to the Fibonacci and Lucas numbers|>
%
% Over the years, I've seen many attempts to generate Fibonacci numbers,
% and occasionally Lucas numbers. Some of those methods are very good,
% some very bad, and some are just plain ugly. I think that the Fibonacci
% sequence is a beautifule one, generated by a simple recursion and
% accessible to students at every level. As an instructor however, one must
% remember to teach your students what can be bad about recursion. Why is
% the factorial function O(N) in its computational complexity when
% generated recursively, while a recursive method to generate a Fibonacci
% number has exponential complexity? So when you teach about Fibonacci
% numbers using recursion, use this as an opportunity to teach them when
% recursion is a bad thing. Use it as an opportunity to teach techniques
% like memoization. Next, show what happens when the numbers get large, then
% teaching about numerical precision issues with floating point numbers.
% Use Fibnonacci numbers as a jumping off point, then teaching a student a
% variety of other things that naturally grow from the discussion.
%
% So when it came time for me to write such a function to generate
% Fibonacci numbers, I decided to think about how best to write one. What
% must it do? My eventual goals for a Fibonacci tool were:
%
% - It must be able to generate the Fibonacci sequence F(n), starting from n = 1, and extending up to some maximum number n.
%
% - Generate the Lucas numbers for the same values of n.
%
% - Generate Fibonacci and Lucas numbers for a specific value of n, or a disconnected list of values.
%
% - Both sequences are defined for positive, negative, and zero values n. The method employed should be able to handle any integer value of n.
%
% - Return exact integer results for any integer input, recognizing that the resulting number may have many thousands of digits.
%
% - Be as efficient as is reasonably possible.
%
% Along the way, I'll look at how one would NOT want to compute Fibonacci numbers.
%
% First of all, I'll try to make sure that everyone knows what Fibonacci numbers are.
% Start by defining the first two terms of the Fibonacci sequence as 1. Thus,
F = [1 1];

%%
% Next, define all further members of the sequence in terms of the previous
% elements. This is called a linear 
% <http://en.wikipedia.org/wiki/Recurrence_relation |recurrence relation|>
% . The relation for the Fibonacci sequence is a simple one.
%
% $$F_n = F_{n-1} + F_{n-2}$$
%
% I'll do a few of them for you.
F(3) = F(2) + F(1)
F(4) = F(3) + F(2)
F(5) = F(4) + F(3)
F(6) = F(5) + F(4)

%%
% The Lucas sequence is very similar, using the same fundamental recurrence relation,
%
% $$L_n = L_{n-1} + L_{n-2}$$
%
% merely starting out from a different starting point.
L = [1 3];
L(3) = L(2) + L(1)
L(4) = L(3) + L(2)
L(5) = L(4) + L(3)
L(6) = L(5) + L(4)

%%
% In fact, as you might expect, the two sequences are very closely related.

%%
% As an aside, some people might start the Fibonacci sequence from |F(0) = 0|.
% Since MATLAB uses an index origin of 1, I'll start at 1 here. In fact, one can
% define the Fibonacci and Lucas sequences for a negative index too, just
% run the fundamental recurrences backwards. Useful identities here are:
%
% $$F_{-n} = {-1}^{n+1} F_n$$
%
% $$L_{-n} = {-1}^n L_n$$

%% Compute the nth Fibonacci number, using a loop
% The simplest way to compute the Fibonacci sequence is to use a loop, based
% on the fundamental recurrences. Suppose we wished to compute |F(25)|? How
% might we do so?
%
% First, I'll preallocate a vector for the entire sequence up to 25.
N = 25;
F = zeros(1,N);
F(1:2) = 1;

%%
% Now just run the loop. See that the cost, in terms of the number of
% additions required is only |N-2 = 23| additions. On each pass through the
% loop, I'll need only to do a single add (along with any overhead due to
% the loop itself.) In fact, this loop
% is rather efficient, but it does require me to store an array of N elements.
% Were N to be very large, this might have been a problem. Of course at
% some point, the size of the number in |F(n)| might be too large to
% represent exactly in terms of a floating point integer. Clearly however,
% if I wish to compute a list of all Fibonacci numbers, this is a very good
% way to do so.
for n = 3:N
  F(n) = F(n-1) + F(n-2);
end
format long g
F(N)

%%
plot(1:N,F,'o')
title('The Fibonacci numbers')
xlabel('N')

%%
% How large is F(N)? The largest number that Matlab can represent as an
% integer exactly when using the double class is 2^53. log2 tells
% us that the 25th Fibonacci number is only a bit over 2^16.
log2(F(25))
%%
% We get the same information from dec2bin. So there is no problem
% computing F(25). However, had we tried to compute F(100), we might have
% been unable to compute the exact result in double precision. So Use of
% large integer utility such as vpi, or that used by the Symbolic toolbox
% would be essential.
dec2bin(F(N))
numel(dec2bin(F(N)))

%%
% Of course, we don't need to save all of those elements if we only wanted
% to compute the number F(25). So one solution might be to retain only the
% last few elements of the sequence. This next loop does exactly that. It
% is slightly more complex, because it must shuffle the results in memory
% too. This is a frequent tradeoff between many algorithms. A faster
% algorithm may sometimes be more memory intensive. How much time does the
% looped algorithm take anyway?
tic
N = 25;
F_nminus2 = 1;
F_nminus1 = 1;
for i = 3:N
  F_n = F_nminus1 + F_nminus2;
  
  F_nminus2 = F_nminus1;
  F_nminus1 = F_n;
end
toc
F_n

%% Fibonacci the slow way, using recursion
% Next, the Fibonacci sequence is often used as an excuse to teach
% recursion. In my opinion, while this is an elegant way to write it,
% recursion can be a computationally horrendous thing to do if done
% improperly. I'll do it the wrong way first, then compare the
% time taken and the operation counts.
%
% (By the way, you might notice that I've deliberately left the help
% on fibrecur and the other functions VERY short. As such, they don't
% even meet my own standards for help. The reason is because they will be
% completely listed in this published file, and you should never
% use them in any serious way. As such, my standard amount
% of help would be too much clutter. The fibonacci tool that I have
% included in my vpi toolbox DOES have complete help. It is called
% fibonacci.m)
dbtype fibrecur

%%
tic,
Fn = fibrecur(25);
toc
Fn

%%
% WOW! That was awfully slow. Why is is so terribly slow? Look at what
% happens. fibrecur(25) calls itself twice, once to evaluate fibrecur(23),
% and the other time to evaluate fibrecur(24). But then fibrecur(23) and
% fibrecur(24) each make two calls, each of which will make two more calls.
% Worse, we end up calling fibrecur(23) twice, one time from fibrecur(25),
% and the other time from fibrecur(24). You can see how this piles up. In
% fact, you might guess that the number of recursive calls goes up
% exponentially with the number being computed. What is the base of the
% exponential function? Think about it. For example, fibrecur(25) requires
% calls to both fibrecur(24) and fibrecur(23), each of which require calls
% to generate the numbers lower than them. So the total number of calls to
% compute the nth fibonacci number is actually the same as the nth
% fibonacci number!
%
% We will learn from the Binet formula that the nth fibonacci number grows
% exponentially, with a base that is essentially

(1+sqrt(5))/2

%%
% To convince ourselves that the time taken is indeed proportional to
% the n'th Fibonacci number itself, Look at the ratio of times. See that
% as n grows large, this ratio approaches 1.618...

tic,
Fn = fibrecur(25);
t25 = toc

%%
tic,
Fn = fibrecur(26);
t26 = toc

%%
t26/t25


%%
% We will show later that a good approximation for the total number of
% recursive calls for fibrecur(n) is
%
%  (1+sqrt(5)/2).^n
%  ----------------
%       sqrt(5)
%
% For example, for n = 25, this predicts roughly 75025 recursive calls.

((1+sqrt(5))/2).^25/sqrt(5)

%%
% While 75025 is not yet an immense number, you need not get too large
% of a number before enponential growth completely overwhelms any computer
% you will choose to use. For example, with n = 100:

((1+sqrt(5))/2).^100/sqrt(5)

%%
% Recursion is a terrible thing to do to a Fibonacci number. To be honest,
% I'm not really sure it is a good thing to teach at all, except as an
% example of what NOT to do. Yes, it is a simple way to teach recursion,
% for a topic that is easily accessible to beginning students. 

%% Fibonacci numbers, using a faster style of recursion
% A nice way to improve the performance of a recursive algorithm
% is to use 
% <http://en.wikipedia.org/wiki/Memoization |Memoization|>
% . Why is this code faster?
dbtype fibrecurmemo

%%
% The fibrecurmemo code does not call itself twice for each
% pass through. Instead, it makes only ONE recursive call, that call returning
% TWO fibonacci numbers. In effect, we never compute the same lower index
% Fibonacci number twice. The change from the previous recursive code is a
% subtle, seemingly minor one, but dramatic in the difference.

%%
% Try this version out. While it is recursive in the sense that it calls
% itself, it is not that slow at all.
% The recursive function calls involve some system overhead, so it is
% slower than the looped code. But it is not too bad. 
%
% To convince you that this algorithm is basically linear in time, if I 
% should double the size of N, a linear algorithm will take roughly twice
% as long to execute. Don't try this with the non-memoized version!
tic,
Fn = fibrecurmemo(25);
toc
Fn

tic,
Fn = fibrecurmemo(50)
toc

tic,
Fn = fibrecurmemo(100);
toc

tic,
Fn = fibrecurmemo(200);
toc

%%
% At some point, even the memoized code will fail, since MATLAB has limits
% on the recursion depth that it will tolerate. By default, that would
% have happened at F(502), when the default recursion limit of 500 in MATLAB will
% be exceeded. Anyway, F(502) is a number with over 100 decimal digits, only
% a few of which will be correct when done in double precision.
% If you really want to compute a number that large and do so efficiently,
% I'll show you how to do it further down. Keep reading.

%% Another method to compute the Fibonacci numbers
% If you recall the plot of the Fibonacci sequence, it was an exponential
% looking curve.
plot(1:N,F,'o')
title('The Fibonacci numbers')
xlabel('N')

%%
% In fact, the Fibonacci sequence is generated by a
% <http://en.wikipedia.org/wiki/Difference_equations |difference equation|>
% , also known as homogeneous recurrence relation. I won't go too deeply into the
% analysis of a recurrence relation here,
% but the Fibonacci sequence is generated by the homogeneous relation
%
%  F(n) - F(n-1) - F(N-2) = 0
%
% Any such homogeneous linear difference equation has an associated
% polynomial, the roots of which provide the solution. Here, the associated
% polynomial is
%
% $$\lambda^2 - \lambda - 1 = 0$$
%
% We can find the roots of the associated polynomial using roots.
roots([1 -1 -1])

%%
% Symbolically those roots are
%
% $$\lambda_1 = \frac{1-\sqrt{5}}{2}$$
%
% $$\lambda_2 = \frac{1+\sqrt{5}}{2}$$
%
% We should expect the Fibonacci numbers to grow roughly exponentially, as
% powers of these roots. The actual form, known as
% <http://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html |Binet's formula|>
% , % is given as
%
% $$F(N) = \frac{(\frac{1+\sqrt{5}}{2})^N - (\frac{1-\sqrt{5}}{2})^N}{\sqrt{5}}$$
lambda1 = (1-sqrt(5))/2;
lambda2 = (1+sqrt(5))/2;
binet = @(N) (lambda2.^N - lambda1.^N)/sqrt(5);

%%
% See that binet computes the 25th Fibonacci number essentially correctly, but as a
% floating point number, not as a true integer. As you should expect from an
% expression that uses real numbers, there is some error down in
% the least significant bits of the result. As such, this is not an
% acceptable way to compute the Fibonacci numbers, but it does give us the
% ability to compute an approximation to their magnitude.
binet(25)

%% A Fibonacci determinant?
% Not all methods to compute Fibonacci numbers need be efficient. I'll take
% a quick look at a couple of them before I go on to better ideas.
%
% Mathematical beauty can arise in a variety of ways. Suppose we were to
% create a tridiagonal matrix, with ones on the main diagonal of the
% matrix, and i = sqrt(-1) on the first sub and super diagonals? The fibmat
% function will do exactly that. See that the matrix is indeed nicely
% tridiagonal.
fibmat = @(N) eye(N) + diag(repmat(sqrt(-1),N-1,1),1) + diag(repmat(sqrt(-1),N-1,1),-1);
spy(fibmat(25))

%%
% What does this have to do with the Fibonacci numbers? Look at what
% happens when I compute the determinants of this sequence of matrices.
for N = 1:10
  det(fibmat(N))
end

%%
% It is initially surprising to many to see the Fibonacci numbers pop out
% from this expression, |det(fibmat(N-1))| yields |F(N)|,
% the Nth Fibonacci number. Ok, I'll admit that use of a matrix determinant
% is wildly overkill to compute a Fibonacci number. On the other hand, 
% it is a result that never fails to make me
% smile. Why should Fibonacci numbers pop out of a determinant? Without
% deriving it for you, I'll just
% suggest that an expansion by minors for the determinant (along the first
% row of the NxN matrix) will actually yield a recurrence relation, relating
% the desired determinant to the determinants of lower order matrices. In
% fact, you will end up deriving the Fibonacci recurrence when you do so.
% Try it. (Please.)
%
% Now, dig a little deeper yet. Recall that the determinant of a matrix is
% the product of the eigenvalues of that matrix. So next, look at the
% eigenvalues of this family of tridiagonal matrices. As it turns out, they all have
% a real part of 1. (At least, approximately so. Remember, we are working
% in floating point arithmetic in all of this.) 
format short g
eig(fibmat(25))

%%
% So discard the real parts of the eigenvalues, sort them, and transform
% them with an arc sine transformation. (I have my devious reasons in all
% of this.)
plot(asin(sort(imag(eig(fibmat(25))))/2),'o')

%%
% Lo and behold, the result is a straight line, so these numbers are
% equally spaced. Looking at the first differences might help to convince
% the skeptics.
diff(asin(sort(imag(eig(fibmat(25))))/2))'

%%
% The eigenvalues of an NxN matrix are the
% roots of an Nth degree characteristic polynomial. A little effort will allow you to
% transform these roots into the roots of a 
% <http://en.wikipedia.org/wiki/Chebyshev_polynomials |Chebyshev polynomial of the second kind|>
% . When you do the transformation, look at the recurrence relation for
% these polynomials. It should be no surprise that it turns out to look
% exactly like that of the Fibonacci numbers. In my opinion, this is yet
% another of those cases where mathematics shows a true beauty, in that different,
% seemingly unrelated areas of mathematics touch upon each other. Here we
% have brought together linear algebra (determinants), special functions (orthogonal
% polynomials), and number theory (Fibonacci numbers). 
%
% N. Cahill, J. D'Errico, J. Spence; "Complex Factorizations of the
% Fibonacci and Lucas Numbers", Fibonacci Quarterly, V.41, No. 1

%% Filternacci
% As long as I'm looking at alternatives methods for the Fibonacci numbers,
% try this one liner:
filter([1],[1 -1 -1],[1 1, zeros(1,30)])

%%
% I'll leave it to the student to understand why the filter call
% works. A closely related idea:
n = 30;
A = eye(n) - diag(ones(n-1,1),-1) - diag(ones(n-2,1),-2);
A(2,1) = 0;
A\[ones(2,1);zeros(n-2,1)]

%%
% The flaw with these methods, i.e., Fibonacci determinants, Fibonacci
% filters and/or linear systems of equations, is all of them are limited
% in their accuracy. Mathematical and programmatical elegance aside, they
% fail a main goal of this effort, i.e., to return an exact integer result.
% They all work in double precision in MATLAB. That
% will greatly limit us in the size of n if we stick to doubles. In fact,
% |F(78) = 8944394323791464| is the largest Fibonacci number that can be
% represented exactly in 53 bits of arithmetic precision. The Lucas numbers
% will exceed that limit above |L(77) = 12360848946698171|.
%
% Therefore any method used must allow large integers to be represented
% exactly if the goals is to return exact results for large n. Clearly a loop
% will be adequate for reasonable values of n, as long as a big integer
% tool is employed.
tic,
N = 1000;
F_nminus2 = vpi(1);
F_nminus1 = vpi(1);
for i = 3:N
  F_n = F_nminus1 + F_nminus2;
  
  F_nminus2 = F_nminus1;
  F_nminus1 = F_n;
end
toc
F_n

%%
% I'd not want to generate |F(1000000)| that way though.

%% Large scale Fibonacci numbers
% Suppose your goal was to compute a single really large Fibonacci number? Perhaps
% you wanted to compute F(100000)? Even given the presence of a biginteger
% toolbox, how might you do this? (I'll use my own vpi tools to do this
% computation, but the symbolic toolbox will work as well.) First of all,
% how many digits are there in such a number?
%
% An answer comes from
% <http://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html |Binet's formula|>
% . For any reasonably large n, F(n) will be dominated by one term in the expression.
%
% $$F(N) \approx \frac{(\frac{1+\sqrt{5}}{2})^N}{\sqrt{5}}$$
%
% Therefore we can find the approximate number of decimal digits in the
% number using a base 10 logarithm.
%
% $$\log_{10}{(F(n))} \approx N \log_{10}{(\frac{1+\sqrt{5}}{2})} - \log_{10}{\sqrt{5}}$$
%
% Thus F(100000) will have just under 21,000 decimal digits.
N = 100000;
N*log10((1+sqrt(5))/2) - log10(sqrt(5))

%%
% Here are a few identities that will prove useful for really large Fibonacci
% numbers.
% 
% $$F_{2n-1} = {F_{n}}^2 + {F_{n-1}}^2$$
%
% $$F_{2n} = 2F_{n-1}F_n + {F_n}^2$$
%
% For those interested in how one might derive these identities, look at
% this 
% <http://www.mathpropress.com/stan/bibliography/algorithmicFib.pdf |paper|>
% . Start with the F(2*n) identity, then replace the Lucas numbers in that
% relation.
%
% The trick is to recursively build the nth Fibonacci number. For example, starting with
% |n = 1000000|, we first recognize that we con compute it from the second of
% these identities, IF we but knew the values of |F(500000)|, and |F(499999)|. 
% Next, we can take one more step backwards, since we can use the same
% identities to find the values of |F(500000)|, and |F(499999)|, given the
% as yet unknown values of |F(250000)|, and |F(249999)|. Continuously
% looking downwards, we will eventually end at F(1), a known value.
%
% What happens if |n| is an odd number? Then |n - 1| must be even.
%
% The fibs1 code
% is fully recursive, but will never generate the same Fibonacci number
% more than once. As well it requires only O(log2(N)) operations to compute
% the Nth Fibonacci number. Note that fibs uses the recent release of my 
% <http://www.mathworks.com/matlabcentral/fileexchange/22725 |vpi toolbox|>
% , as found on the
% <http://www.mathworks.com/matlabcentral/fileexchange/ |MATLAB Central File Exchange|>
% .
dbtype fibs1

%%
% By way of comparison, recall that the loop above to compute F(1000) took about 1.4
% seconds on my machine to do its work.
F_nminus1
F_n

%%
% Compare the use of fibs1.m to compute F(999) and F(1000), 
tic
Fn = fibs1(1000);
toc
Fn

%%
% How about F(100000)? Don't bother using the loop to do so. That would be
% simply too slow here. The funny thing is, fibs took considerably less time
% to compute F(100000), a number with 21,000 decimal digits than the poorly
% written fibrecur took to compute F(25). Even worse, fibrecur was working
% with the standard double precision arithmetic in MATLAB, so in theory, it
% had a significant advantage in speed over the vpi based fibs1.m.
tic
Fn = fibs1(100000);
toc
%%
% Rather than display these entire numbers, was our estimate using Binet's formula correct?
log10(Fn)

%% Large scale Fibonacci and Lucas numbers
% Clearly fibs1 works fairly nicely, to compute isolated Fibonacci numbers,
% but it does not generate the Lucas sequence. The first 25 numbers in the
% pair of related sequences are easily generated with a loop.
F = [1;1;zeros(23,1)];
L = [1;3;zeros(23,1)];
for n = 3:25
  F(n) = F(n-1) + F(n-2);
  L(n) = L(n-1) + L(n-2);
end
format long g
disp('           n        F(n)        L(n)')
disp([(1:25)',F,L])

%%
% A fundamental relation exists 
% between the Fibonacci numbers and the Lucas numbers. Much like in trigonometry,
% where we know the sin and cos functions are related by a fundamental identity,
% |sin(x)^2 + cos(x)^2 == 1|, there also exists an identity that links these
% two integer sequences.
%
% $$L_n^2 - 5F_n^2 = (-1)^n 4$$
%
% Test the identity here. The result should alternate in sign, as +/- 4.
L.^2 - 5*F.^2

%%
% Again, as with the trig family of functions, where we can derive double
% angle formulas, there are identities that allow you to compute the value of F(2*n)
% given only the values of F(n) and L(n). 
%
% $$F_{2n} = F_n L_n$$
%
% $$L_{2n} = \frac{5 F_n^2 + L_n^2}{2}$$
%
% A simple verification of these identities seems appropriate.
n = (1:12)';
disp('Compute F(2*n)')
disp('           n         2*n      F(2*n)   F(n)*L(n)')
[n,2*n,F(2*n),F(n).*L(n)]

%%
disp('Compute L(2*n)')
disp('           n         2*n      L(2*n)  (5*F(n).^2 + L(n).^2)/2')
[n,2*n,L(2*n),(5*F(n).^2 + L(n).^2)/2]

%%
% The identities above work nicely when n is even. If n is odd, just
% subtract 1, and it will be even, allowing us to use the 2*n rules
% we just saw. Afterwards, two more identities allow us to shift back
% up one step.
%
% $$F_{m+1} = \frac{F_m + L_m}{2}$$
%
% $$L_{m+1} = \frac{5 F_m + L_m}{2}$$
%
% fibs2 uses these identities to efficiently compute the pair F(n) and L(n).
dbtype fibs2

%%
% Apply fibs2 to compute F(100000) and L(100000) as a coupled pair.
tic,[Fn,Ln] = fibs2(100000);toc

%%
% See that fibs2 was a bit slower than fibs1, but it returns both the last
% two Fibonacci numbers, as well as the last two Lucas numbers. And, fibs2
% is still a recursive function, so there is function call overhead wasted
% every time fibs2 gets invoked.
% 
% fibs2 is not the end to how might optimize the computation of the Fibonacci numbers.
% There are other steps one can take. In fact, very often careful
% programming can allow a recursive code to be re-written as an simply looped code.
% This has been done with fibs3, by working with the binary representation of the
% original number n. Think about what was done by fibs2. Each pass through,
% fibs2 divides by 2 if n is even, or subtracts 1 and then divides by 2 if it 
% is odd. Look at the result of such an operation at each step. I'll start
% with n = 197 as an example:
n = 197
dec2bin(n)
%%
% n was odd, so subtract 1, then divide by 2.
n = (n - 1)/2,dec2bin(n)
%%
% n was even, so just divide by 2.
n = n/2,dec2bin(n)
%%
% Repeat each operation as indicated by the next bit in the binary representation.
n = (n - 1)/2,dec2bin(n)
n = n/2,dec2bin(n)
n = n/2,dec2bin(n)
n = n/2,dec2bin(n)
n = (n - 1)/2,dec2bin(n)

%%
% fibs3 starts with a binary representation of n, then works UPWARDS
% through this same chain in a simple loop. Also, fibs3 uses a slightly
% different pair of identities to minimize the number of multiplies and divides
% at each step. 
dbtype fibs3

%%
% fibs3 has become fairly efficient.
tic,
[Fn,Ln] = fibs3(100000);
toc

%%
% My final version is embodied in fibonacci.m. This code uses the ideas in
% fibs3 to compute isolated Fibonacci and Lucas numbers efficiently. In the
% event that sets of numbers are requested, an addition identity is employed,
% relating |F(m + n)| and |L(m + n)| with lower order numbers.
dbtype fibonacci

%%
% I'll give up here. Perhaps there will be some ideas gained
% by some of my readers on how to compute and work with Fibonacci numbers.
% Even if not, I'll hope that someone has learned some tricks on how to
% write recursive functions, and how to recognize when recursion may be
% inappropriate.
tic,
[Fn,Ln] = fibonacci(100000);
toc

%%
% F(100000), the 100,000th Fibonacci number
Fn
%%
% L(100000), the 100,000th Lucas number
Ln

