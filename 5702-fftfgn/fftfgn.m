%
% Author: Stilian Stoev (C), sstoev@math.bu.edu
%
% Generates paths of fractional Gaussian noise.  The algorithm exploits
% the efficiency of the FFT algorithm. 
%
% * Written by: Stilian Stoev <sstoev@math.bu.edu>.  
% * Latest revision: October 5, 2003.
%
% * When 0<H<1/2
%    The generated paths have "exact distributions", discarding
%  the effect of the random number generator.  The code uses
%  the "corrected" algorithm of Steven B. Lowen, 1999 
%  "Efficient Generation of Fractional Brownian Motion for
%   Simulation of Infrared Focal-plane Array Calibration Drift"
%
% * When 1/2<H<1 
%   The paths are generated by using a truncated symmetric moving average
% filter.  The filter coefficients are computed via IFFT of the square
% root of the FFT of the covariances of the FGN.
%   The moving average is also computed by using the FFT algorithm.
%
%  *Remark* This method is simple, and probably similar to "circulant 
% embedding techniques", numerically.  It is, however, more general and
% easier to extend for arbitrary covariance strucures.  It is originally
% due to Stilian Stoev <sstoev@math.bu.edu>. Please email if you know
% of other similar algorithms.
%
% Input:
%   sigma <- the variance
%       H <- Hurst
%       n <- number of independent samples to be generated.
%       N <- the size of the sample 
%       M <- 1/2 of the length of the filter to be used
%            (used only for 1/2<H<1)
%   force <- if force == 1, then the FFT's in the case 1/2 <H< 1 
%            are forced to be of dyadic complexity.
%
% *Note: The generation is most efficient if:
%         * N       is an integer power of 2 (when 0<H<1/2)
%         * (N+2*M) is an integer power of 2 (when 1/2<H<1)
%       
% Output:
%       f <- (nxN) matrix. Each row gives a sample path of FGN.
%
% Usage:
%  f = fftfgn(sigma,H,n,N,M,force);
%
function f = fftfgn(sigma,H,n,N,M,force,varargin)

if H==1/2,
 f = sigma*randn(n,N);
elseif and((H>1/2),H<=1)
 t=[-M:M];
 co =.5*sigma^2*(abs(t+1).^(2*H) + abs(t-1).^(2*H) - 2*abs(t).^(2*H));
 if force,
  nM = 2^(fix(log2(2*M+1))+1);
 else
  nM = 2*M+1;
 end;
  co_hat =fft(co,nM);
 ft = real(ifft(abs(co_hat).^.5,nM));
 ft = [ft(fix(nM/2)+1:nM), ft(1:fix(nM/2))];
 R  = randn(n,2*M+N); 

 if ~isempty(varargin),
   fprintf(' Generating n = %d paths ',n);
 end;

 f  = [];
 for i=1:n,
    fi = fftconv(R(i,:),ft,force);
    f  = [f; fi(2*M:2*M+N-1)];
    if ~isempty(varargin),
     fprintf('.');
    end;
 end;
  if ~isempty(varargin),
     fprintf(' done.\n');
    end;

 elseif and((H<1/2),H>0)

     G1=randn(n,N-1);  
     G2=randn(n,N-1);
     G = (G1+sqrt(-1)*G2)/sqrt(2);  
     GN = randn(n,1);
     G0 = zeros(n,1);
     H2=2*H;       
     R=(1-((1:N-1)/N).^H2);
     R=[1 R 0 R(N-1:-1:1)];
     S=ones(n,1)*(abs(fft(R,2*N)).^.5);
     X=[zeros(n,1) G, GN, conj(G(:,N-1:-1:1)) ].*S;  
     x=ifft(X',2*N)';
     y=sqrt(N)*real((x(:,1:N)-x(:,1)*ones(1,N)));
     f = sigma*N^H*[y(:,1), diff(y')'];
 else
  error('The value of the Hurst parameter H is out of the range (0,1]');
 end;
