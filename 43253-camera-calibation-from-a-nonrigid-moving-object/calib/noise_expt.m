% experiment to determine performance under various noise conditions 
% (outliers are not included in these tests). The results correspond to
% figures 4 and 5 of Tresadern and Reid, IVC 2008, generated by running
% noise_results.m
%
% © Copyright Phil Tresadern, University of Oxford, 2006

clear all; close all; clc;
addpath('./toolbox');

% where to load/save data and figures
datapath	= './data/';
figpath		= './figs/synth_run/';
	
load([datapath,'synth_run.mat']);

rng	= 1:30; % use first 30 frames
W		= lr2W(W1(rng,:),W2(rng,:),0);
Xgt	= Xgt(:,:,rng);

% should really have used a fixed value but too late now
rand('state',sum(100*clock));

% precompute ground truth values
[intra,inter] = assign_cons(W);
	inter	= [inter; 1 8; 1 11];
W_gt		= lr2W(W1(rng,:),W2(rng,:),0);
X_gt		= Xgt(:,:,rng);
L_gt		= median(get_lengths(X_gt,inter),1);
X_gt		= X_gt / L_gt(1);
L_gt		= L_gt / L_gt(1);
Phi_gt	= compute_poses(X_gt,inter);

% setup variables
sigmas	= [0:0.5:4]; nTests	= 1; % used for debugging
% sigmas	= [0:0.2:4]; nTests	= 20; % used for the IVC paper (I think)

% create matrices for 11 error values:
%   [ rms, rms_joint, limb_err, phi_r, omega_r, 
%     #its (local), time (local), #its (global), time (global), converged,
%     Topt, Ttot ]
nerr = 11;
errors = struct('lieb',zeros(length(sigmas),nerr,nTests),...
								'min',zeros(length(sigmas),nerr,nTests),...
								'abundle',zeros(length(sigmas),nerr,nTests),...
								'pbundle',zeros(length(sigmas),nerr,nTests));

for isigma = 1:length(sigmas)
	for t = 1:nTests
		clc; disp([sigmas(isigma),t]);
		
		% create noisy version of data
		Wn = W_gt + sigmas(isigma)*randn(size(W_gt));

		% reset constraints
		[intra,inter] = assign_cons(Wn);
		
		nframes	= size(Wn,3);
		npoints	= size(Wn,2);

		
		% process via Liebowitz first
		t0 	= clock;
		[S,P,X,T,opt_data] = calib_lieb(Wn,intra,inter);
			[S,P,X,L,Phi] = fix_lengths(S,P,X,[inter; 1 8; 1 11]);
			Wnew	= zeros(4,npoints,nframes);
			for f = 1:nframes, Wnew(:,:,f) = S(:,:,f)*P*X(:,:,f) + T(:,ones(1,npoints));	end
			[errs] = compute_errors(W_gt,Wnew,P,L_gt,L,Phi_gt,Phi);
 			errors.lieb(isigma,:,t) = [errs,opt_data,etime(clock,t0)];
		
			
		% then do again using minimal parameterization
		t0 	= clock;
		[S,P,X,T,opt_data] = calib_minimal(Wn,intra,inter);
			[S,P,X,L,Phi] = fix_lengths(S,P,X,[inter; 1 8; 1 11]);
			Wnew	= zeros(4,npoints,nframes);
			for f = 1:nframes, Wnew(:,:,f) = S(:,:,f)*P*X(:,:,f) + T(:,ones(1,npoints));	end
			[errs] = compute_errors(W_gt,Wnew,P,L_gt,L,Phi_gt,Phi);
 			errors.min(isigma,:,t) = [errs,opt_data,etime(clock,t0)];


		% affine bundle adjustment
		t0 	= clock;
		[Sb,Pb,Tb,Lb,Phib,opt_data,Wnew] = bundle_affine(S,P,T,L,Phi,Wn);
			[errs] = compute_errors(W_gt,Wnew,Pb,L_gt,Lb,Phi_gt,Phib);
			errors.abundle(isigma,:,t) = [errs,opt_data,etime(clock,t0)];

		
		% perspective bundle adjustment
		t0 	= clock;
		C1					= mycamcald([X(:,:);Wn(1:2,:)]');
		[K1,R1,t1]	= getcparams(C1);
		if (t1(3) < 0)
			P(:,3)			= -P(:,3);
			X(3,:)			= -X(3,:);
			C1					= mycamcald([X(:,:);Wn(1:2,:)]');
			[K1,R1,t1]	= getcparams(C1);
		end

		% transform structure so that 1st camera is aligned with global frame
		X(:,:)			= R1*X(:,:) + t1*ones(size(X(1,:)));
		Phi					= compute_poses(X,inter);

		% get camera matrix that best generates second view data from known
		% structure
		C2					= mycamcald([X(:,:);Wn(3:4,:)]');

		% replace rotation with what we computed before
		[K2,R2,t2]	= getcparams(C2);
		R2					= [P(3:4,:); cross(P(3,:),P(4,:))];

		[P1,P2,Lb,Phib,opt_data,Wnew] = bundle_persp(K1,K2,R2,t2,L,Phi,Wn,inter);
		[K,Pb]			= getcparams(P2);
		Pb					= [1 0 0; 0 1 0; Pb(1:2,:)];
		[errs]			= compute_errors(W_gt,Wnew,Pb,L_gt,Lb,Phi_gt,Phib);
		errors.pbundle(isigma,:,t) = [errs,opt_data,etime(clock,t0)];
	end
end

errorstats.lieb.mean = mean(errors.lieb,3);
	errorstats.lieb.std = std(errors.lieb,0,3);
errorstats.min.mean = mean(errors.min,3);
	errorstats.min.std = std(errors.min,0,3);
errorstats.abundle.mean = mean(errors.abundle,3);
	errorstats.abundle.std = std(errors.abundle,0,3);
errorstats.pbundle.mean = mean(errors.pbundle,3);
	errorstats.pbundle.std = std(errors.pbundle,0,3);

if ~exist('./data/noise/','dir')
	mkdir('./data/noise/');
end
save('./data/noise/newerrors.mat','sigmas','errors','errorstats');

